from node import Nodefrom linkedQueue import LinkedQueuedef main():        maze = getMazeFromFile()    printMaze(maze)    (startRow, startCol) = findStartPos(maze)     probe = getOut(startRow, startCol, maze)    printMaze(maze)    (rt,ct) = probe.data        if probe != None:        print("Maze has a solution.")        s = " "        count = 0        while probe != None:            (r,c) = probe.data            maze[r][c] = '@'            probe = probe.next            s = str((r,c)) + " " + s            count += 1                    maze[startRow][ startCol] = 'P'        maze[rt][ct] = 'T'        printMaze(maze)        print("The length of the shortest path is: ", count )        print("The path is: ")        print(s)    else:        print ("Maze has no solution.")        def printMaze( maze):    for i in range(len(maze)):        #s = "".join([c for c in maze[i]])        s="".join(maze[i])        print(str(s))              def getMazeFromFile():    filename = "maze.txt"    fileObj = open(filename, 'r')    firstLine = fileObj.readline().strip().split()    rows = int (firstLine[0])    columns = int(firstLine[1])    print(str(rows) + " " + str(columns))        maze=[]    for row in range(rows):        tmp = ['*'] * columns        maze.append(tmp)    for row in range(rows):        line = fileObj.readline().strip()        column = 0        for ch in line:            maze[row][column] = ch            column += 1    return mazedef findStartPos(maze):    """Returns the position of the start symbol in the grid."""    for row in range(len(maze)):        for column in range(len(maze[row])):            if maze[row][column] == 'P':                return (row, column)    return (-1, -1)                def getOut(row, column, maze):    """(row,column) is the position of the start symbol in the maze.    Returns True if the maze can be solved or False otherwise."""    # States are tuples of coordinates of cells in the grid.    letter = '+'    q = LinkedQueue()    q.enqueue(  Node((row, column), None))    while len(q) > 0:        c = q.dequeue()        (row, column) = c.data        count = 0        if  maze[row][column] == 'T':             return c        elif maze[row][column] != letter:            # Cell has not been visited, so mark it and push adjacent unvisited            # positions onto the stack            maze[row][column] = letter            # Try NORTH            if row != 0 and not maze[row - 1][column] in ('*', letter):                q.enqueue(  Node((row - 1, column), c))            # Try SOUTH            if row + 1 != len(maze) and not maze[row + 1][column] in ('*',letter):                         q.enqueue(  Node((row + 1, column), c))            # Try EAST            if column + 1 != len(maze[row]) and not maze[row][column + 1] in ('*', letter):                         q.enqueue(  Node((row, column + 1), c))            # Try WEST            if column != 0 and not maze[row][column - 1] in ('*', letter):                         q.enqueue(  Node((row, column - 1), c))                    return Nonemain()